#!/bin/bash

###################################################################################################
#
# Find all lines or multi-line paragraphs which contain a set of strings in filtered files
# of current folder and its subfolders recursively, in a simple way for most common usage,
# without need of complex regular expressions. Special characters and binary files contents
# can be searched.
#
# USAGE:
#  fl [-i] [-p=N] [-w] [pathstr|/pathstr]* str [+|-|++|-- str]*
#
# DESCRIPTION:
#  The goal of this linux bash script is to simply and quickly display all the lines
#  or multi-line paragraphs matching the str parameters in all the files being filtered
#  by the pathstr parameters, see below examples.
#  Special characters (like *, +, |, :, ...) do not need to be escaped, they are searched
#  directly as provided in the str parameters, which makes the usage very simple.
#  Binary files contents are also searched, so that as many matching lines as possible are
#  displayed at the end and no occurrence is missed.
#
# OPTIONS:
#  -i: ignore lower/upper case during the search
#  -p=N: consider paragraphs of 2N+1 lines during the search (N >= 1) instead of line
#        by line search (2N+1 = N lines before first str matching line + first str
#        matching line + N lines after first str matching line)
#  -w: first str to find shall be a whole word (word-constituent characters are letters,
#      digits and underscore)
#
# EXAMPLES:
#  fl str
#    => find all lines containing str in all files of current folder and its subfolders
#  fl .c str
#    => find all lines containing str in the .c files of current folder and its subfolders
#  fl .c .h str1 + str2 - str3
#    => find all lines containing str1 and str2 and not str3 in the .c or .h files
#       of current folder and its subfolders
#  fl .c .h str1 ++ str2 -- str3
#    => find all lines containing str1 and then str2 and then not str3 in the .c or .h files
#       of current folder and its subfolders
#  fl mypathstr str
#    => find all lines containing str in the files of current folder and its subfolders
#       whose path contains "mypathstr" ("mypathstr" in file or folder names)
#  fl .c /mypathstr str
#    => find all lines containing str in the .c files of current folder and its subfolders
#       whose path does not contain "mypathstr" ("mypathstr" not in file and folder names)
#  fl -i .c str
#    => find all lines containing str in the .c files of current folder and its subfolders
#       with lower/upper case ignored
#  fl -p=1 .c str1 + str2
#    => find all 3 lines long paragraphs containing str1 and str2 in the .c files
#       of current folder and its subfolders
#  fl -p=2 .c str1 ++ str2 -- str3
#    => find all 5 lines long paragraphs containing str1 and then str2 and then not str3
#       in the .c files of current folder and its subfolders
#  fl -w .c str
#    => find all lines containing the whole word "str" in the .c files of current folder
#       and its subfolders
#
#  Of course, all operators +/-/++/-- and all options -i/-p=N/-w can be used jointly.
#
#  Examples of searches with special characters:
#  - Special characters can be searched directly, for example
#    fl "(a*b+[(x/y)-z] || d == e & f)" will search exactly this string without need to escape
#    the special characters.
#  - Linux shell's special characters \, $, ` and " shall be escaped with \\, \$, \` and \" respectively.
#    For example fl "\\xxx\$" will search all lines containing "\xxx$" in all files.
#  - Special characters can also be searched directly with their ASCII code, for example:
#    fl $'\x09' will search all lines containing tab characters (\t) in all files,
#    fl $'\x0D' will search all lines containing carriage return characters (\r) in all files.
#
###################################################################################################

###########
# Constants
###########

export LC_ALL=en_US.UTF-8

MAX_ABBREVIATION_LEN=80
MAX_LEN_FOR_LINE_SPLIT=140

ERROR_COLOR=$'\E[1m\E[4m\E[31m'    # Red
SOURCE_COLOR=$'\E[1m\E[4m\E[31m'   # Red
HEADER_COLOR=$'\E[1m\E[4m\E[32m'   # Green
OTHER_COLOR=$'\E[1m\E[4m\E[36m'    # Cyan
FILEPATH_COLOR=$'\E[2m\E[37m'      # White
BOLD=$'\E[1m'
ITALIC=$'\E[3m'
NC=$'\E[0m'

character_separator="§"
paragraph_separator="§§§§§§§§§§"
paragraph_line_separator="${paragraph_separator}§§§§§"
no_match="[?????]"
grep_ignorecase_option="-i"
grep_word_option="-w"

abbreviation_str="$BOLD [...] $NC"

###########
# Functions
###########

# print error message
printError() {
    local error_str=$1

    echo -e -n "$ERROR_COLOR" >&2
    echo -n "$error_str" >&2
    echo -e "$NC" >&2
}

# display spaces
display_spaces() {
    local nb_spaces=$1

    spaces_str=$(printf "%${nb_spaces}s")
    echo "$spaces_str"
}

# abbreviate long strings
abbreviate() {
    local str=$1

    length=${#str}
    if [[ $length -gt $((MAX_ABBREVIATION_LEN * 2 + 10)) ]]; then
        abbreviated_str_1="${str:0:MAX_ABBREVIATION_LEN}" # substring
        abbreviated_str_1="${abbreviated_str_1%"${abbreviated_str_1##*[![:space:]]}"}" # right trim
        idx=$((length - MAX_ABBREVIATION_LEN))
        abbreviated_str_2="${str:idx:MAX_ABBREVIATION_LEN}" # substring
        abbreviated_str_2="${abbreviated_str_2#"${abbreviated_str_2%%[![:space:]]*}"}" # left trim
        abbreviated_str=$(echo "$abbreviated_str_1$abbreviation_str$abbreviated_str_2")
        echo "$abbreviated_str"
    else
        echo "$str"
    fi
}

# escape special characters as needed by grep -E commmand
escape_special_chars() {
    local str=$1

    echo "$str" | sed 's/\\/\\\\/g' | sed 's/\[/\\[/g' | sed 's/\]/\\]/g' | sed 's/+/\\+/g' | sed 's/(/\\(/g' | sed 's/)/\\)/g' | sed 's/{/\\{/g' | sed 's/}/\\}/g' | sed 's/\./\\./g' | sed 's/\^/\\^/g' | sed 's/\$/\\$/g' | sed 's/\?/\\?/g' |  sed 's/!/\\!/g' | sed 's/|/\\|/g' | sed 's/\*/\\*/g' | sed 's/-/\\-/g'
}

# check if 2 strings are "correlated"
correlated_strings() {
    local str1_p=$1
    local str2_p=$2
    local ignorecase_p=$3
    local word_for_str1_p=$4

    if [[ $ignorecase_p -eq 0 ]]; then
        if [[ $word_for_str1_p -eq 0  ]]; then
            str1=$(echo "$str1_p")
            str2=$(echo "$str2_p")
        else
            # this simple str1_p reformatting covers most of cases
            str1=$(echo " $str1_p " | sed 's/[^a-zA-Z0-9_]/ /g')
            str2=$(echo "$str2_p" | sed 's/[^a-zA-Z0-9_]/ /g')
        fi
    else
        if [[ $word_for_str1_p -eq 0  ]]; then
            str1=$(echo "$str1_p" | tr '[:upper:]' '[:lower:]')
            str2=$(echo "$str2_p" | tr '[:upper:]' '[:lower:]')
        else
            # this simple str1_p reformatting covers most of cases
            str1=$(echo " $str1_p " | tr '[:upper:]' '[:lower:]' | sed 's/[^a-zA-Z0-9_]/ /g')
            str2=$(echo "$str2_p" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-zA-Z0-9_]/ /g')
        fi
    fi

    str1_length=${#str1}
    str2_length=${#str2}
    min_str_length=$(( str1_length < str2_length ? str1_length : str2_length ))
    if [[ $min_str_length -eq 0 ]]; then
        echo "0"
        return
    fi

    # check if strings are included in each other
    if [[ "$str1" == *"$str2"* || "$str2" == *"$str1"* ]]; then
        echo "1"
        return
    fi
    # check if strings have common start/end substrings, taking into account word boundaries
    len=1
    while [[ $len -le $min_str_length ]]; do
        startsubstr1="${str1:0:len}" # substring
        if [[ "$str2" == *"$startsubstr1" ]]; then
            echo "1"
            return
        fi
        startsubstr2="${str2:0:len}" # substring
        if [[ "$str1" == *"$startsubstr2" ]]; then
            echo "1"
            return
        fi
        len=$((len + 1))
    done
    echo "0"
}

# gather paragraph lines
gather_paragraph_lines() {
    paragraph_lines=""
    at_least_one_line=0
    # in this loop, "IFS=" avoids input lines being trimmed
    while IFS= read -r input_str; do
        at_least_one_line=1
        if [[ "$input_str" == "$paragraph_separator" ]]; then
            if [[ "$paragraph_lines" == "" ]]; then
                printError "gather_paragraph_lines error: empty paragraph"
                exit 1
            fi
            echo "$paragraph_lines"
            paragraph_lines=""
            echo "$paragraph_separator"
        else
            if [[ "$paragraph_lines" == "" ]]; then
                paragraph_lines="$input_str"
            else
                paragraph_lines="$paragraph_lines$paragraph_line_separator$input_str"
            fi
        fi
    done
    if [[ "$paragraph_lines" == "" && $at_least_one_line -ne 0 ]]; then
        printError "gather_paragraph_lines error: empty ending paragraph"
        exit 1
    fi
    echo "$paragraph_lines"
}

# format output
format_output() {
    local searched_str_p=$1
    local grep_ignorecase_option_p=$2
    local grep_word_option_p=$3
    local paragraph_size_p=$4

    if ! [[ "$paragraph_size_p" =~ ^[0-9]+$ ]]; then
        printError "format_output error: paragraph size \"$paragraph_size_p\" is not a number"
        exit 1
    fi

    searched_str_length=${#searched_str_p}
    if [[ $searched_str_length -eq 0 ]]; then
        printError "format_output error: empty searched_str_p"
        exit 1
    fi
    reformatted_searched_str_p=$(escape_special_chars "$searched_str_p")

    last_filepath=""
    last_binary_filepath=""
    highlight_color="$OTHER_COLOR"
    non_printable_status=0
    total_nb_lines_displayed=0

    # in this loop, "IFS=" avoids input lines being trimmed
    while IFS= read -r input_str; do

        if [[ "$input_str" == "" ]]; then
            continue
        fi

        input_str_length=${#input_str}

        # extract filepath and line number
        # input_str format is ./xxx/yyy/zzz.txt:123:line_contents or ./xxx/yyy/zzz.txt-123-line_contents (possible in paragraph mode)
        OLDIFS=$IFS
        IFS=":"
        read -r filepath line_number current_input_str <<< "$input_str"
        IFS=$OLDIFS # restore IFS
        filepath_extracted=0
        filepath_extracted_par=0
        if [[ "$line_number" =~ ^[0-9]+$ ]]; then
            if [[ "$current_input_str" == "" && $paragraph_size_p -eq 0 ]]; then
                printError "unexpected empty matching line for $filepath:$line_number"
                exit 1
            fi
            filepath_and_line_number_str="$filepath:$line_number"
            reformatted_filepath_and_line_number_str="${filepath_and_line_number_str#./}" # remove leading ./
            skip_occurrence_number_display=0
            filepath_extracted=1
        else
            # try slower method
            filepath_and_line_number_str=$(grep --text -o -P "^\./.*?:[0-9]+:" <<< "$input_str") # Perl regexp is used for non-greedy mode (not supported by Extended Regular Expressions with grep -E)
            filepath_and_line_number_length=${#filepath_and_line_number_str}
            if [[ $filepath_and_line_number_length -ne 0 ]]; then
                reformatted_filepath_and_line_number_str="${filepath_and_line_number_str#./}" # remove leading ./
                reformatted_filepath_and_line_number_str="${reformatted_filepath_and_line_number_str%:}" # remove ending :
                line_number_with_separators=$(grep -o -E ":[0-9]+:$" <<< "$filepath_and_line_number_str")
                line_number_with_separators_length=${#line_number_with_separators}
                idx=$((filepath_and_line_number_length - line_number_with_separators_length))
                filepath="${filepath_and_line_number_str:0:idx}" # substring
                length=$((input_str_length - filepath_and_line_number_length))
                current_input_str="${input_str:filepath_and_line_number_length:length}" # substring
                if [[ "$current_input_str" == "" && $paragraph_size_p -eq 0 ]]; then
                    printError "unexpected empty matching line for $reformatted_filepath_and_line_number_str"
                    exit 1
                fi
                skip_occurrence_number_display=0
                filepath_extracted=1
            fi
        fi
        if [[ $paragraph_size_p -ne 0 ]]; then
            if [[ "$input_str" == "$paragraph_separator" ]]; then
                continue
            else
                IFS="-"
                read -r filepath_par line_number_par current_input_str_par <<< "$input_str"
                IFS=$OLDIFS # restore IFS
                if [[ "$line_number_par" =~ ^[0-9]+$ ]]; then
                    filepath_and_line_number_str="$filepath_par-$line_number_par"
                    reformatted_filepath_and_line_number_str_par="${filepath_and_line_number_str#./}" # remove leading ./
                    filepath_extracted_par=1
                else
                    # try slower method
                    filepath_and_line_number_str=$(grep --text -o -P "^\./.*?-[0-9]+-" <<< "$input_str") # Perl regexp is used for non-greedy mode (not supported by Extended Regular Expressions with grep -E)
                    filepath_and_line_number_length=${#filepath_and_line_number_str}
                    if [[ $filepath_and_line_number_length -ne 0 ]]; then
                        reformatted_filepath_and_line_number_str_par="${filepath_and_line_number_str#./}" # remove leading ./
                        reformatted_filepath_and_line_number_str_par="${reformatted_filepath_and_line_number_str_par%-}" # remove ending -
                        line_number_with_separators=$(grep -o -E "\-[0-9]+-$" <<< "$filepath_and_line_number_str")
                        line_number_with_separators_length=${#line_number_with_separators}
                        idx=$((filepath_and_line_number_length - line_number_with_separators_length))
                        filepath_par="${filepath_and_line_number_str:0:idx}" # substring
                        length=$((input_str_length - filepath_and_line_number_length))
                        current_input_str_par="${input_str:filepath_and_line_number_length:length}" # substring
                        filepath_extracted_par=1
                    fi
                fi
            fi
            if [[ $filepath_extracted_par -eq 1 ]]; then
                # in paragraph mode, select shortest possible filepath so that all occurrences will be properly highlighted
                # and filepath will never contain non-printable characters
                if [[ $filepath_extracted -eq 0 || ${#filepath_par} -lt ${#filepath} ]]; then
                    filepath="$filepath_par"
                    current_input_str="$current_input_str_par"
                    reformatted_filepath_and_line_number_str="$reformatted_filepath_and_line_number_str_par"
                    skip_occurrence_number_display=1
                fi
            fi
        fi
        if [[ $filepath_extracted -eq 0 && $filepath_extracted_par -eq 0 ]]; then
            printError "format_output error: cannot extract filepath and line number from \"$input_str\""
            exit 1
        fi
        if [[ $current_input_str == "" ]]; then
            echo -e "$(display_spaces ${#total_nb_lines_displayed}) $FILEPATH_COLOR$reformatted_filepath_and_line_number_str$NC"
            continue
        fi

        if [[ "$last_filepath" != "$filepath" ]]; then
            # specific formatting (conditions on filepath to be adapted as needed - with below conditions, test files will be displayed in italic)
            specific_formatting=""
            if [[ "$filepath" == *"test"* || "$filepath" == *"Test"* || "$filepath" == *"TEST"* || "$filepath" == *"tst"* ]]; then
                specific_formatting="$ITALIC"
            fi
            # source files (conditions on file suffix to be adapted as needed)
            if [[ "$filepath" == *".c" || "$filepath" == *".cpp" || "$filepath" == *".java" ]]; then
                highlight_color="$SOURCE_COLOR$specific_formatting"
                non_printable_status=0
            # header files (conditions on file suffix to be adapted as needed)
            elif [[ "$filepath" == *".h" || "$filepath" == *".hh" || "$filepath" == *".hpp" ]]; then
                highlight_color="$HEADER_COLOR$specific_formatting"
                non_printable_status=0
            # common non binary files
            elif [[ "$filepath" == *".txt" || "$filepath" == *".js" || "$filepath" == *".log" || "$filepath" == *".html" || "$filepath" == *".xml" || "$filepath" == *".csv" ]]; then
                highlight_color="$OTHER_COLOR$specific_formatting"
                non_printable_status=0
            # common binary files
            elif [[ "$filepath" == *".o" || "$filepath" == *".obj" || "$filepath" == *".png" || "$filepath" == *".jpg" || "$filepath" == *".docx" || "$filepath" == *".zip" || "$filepath" == *".gz" || "$filepath" == *".bin" ]]; then
                highlight_color="$OTHER_COLOR$specific_formatting"
                non_printable_status=1
            # other files
            else
                highlight_color="$OTHER_COLOR$specific_formatting"
                # check if current_input_str contains non printable characters (binary line detection)
                # Notes:
                # - non-ASCII characters (<=> command "grep -qE $'[^\x01-\x7F]';") are multi-byte and are supported by this script so are not considered as non printable
                # - \r characters are supported only when at line end (aka Ctrl+M or "carriage return" characters = \x0D in ASCII, typically present in Windows files at line ends) because can lead to invalid display
                # - impossible to check \x00 presence in a string with a bash script => \x00 is considered as printable and a warning message will be displayed if needed
                if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< "$current_input_str")" != "" ]]; then # code duplicated in unit tests (a little slower but better than tr -d '[:print:][:blank:]\r§µ¨£°²' which operates based on single-byte ASCII characters by default)
                    non_printable_status=1
                else
                    # check \r character presence at line end
                    tmp_current_input_str="${current_input_str%$'\n'}" # remove ending \n
                    tmp_current_input_str="${tmp_current_input_str%$'\r'}" # remove ending \r because can lead to invalid display
                    if [[ "$tmp_current_input_str" == *$'\r'* ]]; then
                        non_printable_status=1
                    else
                        non_printable_status=0
                    fi
                fi
            fi
            last_filepath="$filepath"
        fi

        # Case all characters are printable
        if [[ $non_printable_status -eq 0 ]]; then

            current_input_str_length=${#current_input_str}

            if [[ $input_str_length -ge $MAX_LEN_FOR_LINE_SPLIT && $paragraph_size_p -eq 0 ]]; then
                leading_spaces="${current_input_str%%[^ ]*}"
                leading_spaces_count=${#leading_spaces}
                trailing_spaces="${current_input_str##*[^ ]}"
                trailing_spaces_count=${#trailing_spaces}

                # indentation is replaced by a \t or new line if line is very long
                reformatted_filepath_and_line_number_str_length=${#reformatted_filepath_and_line_number_str}
                if [[ $((reformatted_filepath_and_line_number_str_length + current_input_str_length - leading_spaces_count - trailing_spaces_count)) -le $MAX_LEN_FOR_LINE_SPLIT ]]; then
                    separator="\t"
                else
                    separator="\n"
                fi
            else
                separator="\t"
            fi
            if [[ $skip_occurrence_number_display -eq 0 ]]; then
                total_nb_lines_displayed=$((total_nb_lines_displayed + 1))
                echo -e -n "$FILEPATH_COLOR$total_nb_lines_displayed $reformatted_filepath_and_line_number_str$NC$separator"
            else
                echo -e -n "$(display_spaces ${#total_nb_lines_displayed}) $FILEPATH_COLOR$reformatted_filepath_and_line_number_str$NC$separator"
            fi

            at_least_one_occurrence_on_line=0
            while true; do
                # get offset of reformatted_searched_str_p in current_input_str in bytes, using the same grep command and options as in main search to keep full compatibility between search and formatting
                byte_idx_str=$(grep -E --text -o -b $grep_ignorecase_option_p $grep_word_option_p -- "$reformatted_searched_str_p" <<< "$current_input_str" | head -n 1)
                byte_idx=${byte_idx_str%%[^0-9]*}
                if [[ "$byte_idx" == "" ]]; then
                    idx=-1
                else
                    # convert number of bytes into number of characters, useful for multi-byte non-ASCII characters
                    char_idx=$(echo -n "$current_input_str" | head -c $byte_idx | wc -m)
                    idx=$char_idx
                fi

                if [[ $idx -eq -1 ]]; then
                    if [[ $at_least_one_occurrence_on_line -eq 0 && $paragraph_size_p -eq 0 ]]; then
                        # warning that no occurrence was successfully highlighted on current line: can occur due to \x00 specical character
                        echo -e -n "$highlight_color$no_match$NC "
                        current_input_str="${current_input_str#"${current_input_str%%[![:space:]]*}"}" # left trim
                    fi
                    if [[ "$current_input_str" != "" ]]; then
                        tmp_abbreviated_str="${current_input_str%"${current_input_str##*[![:space:]]}"}" # right trim
                        tmp_abbreviated_str=$(abbreviate "$tmp_abbreviated_str")
                        echo -n "$tmp_abbreviated_str"
                    fi
                    break
                fi
                if [[ $idx -gt 0 ]]; then
                    tmp_str="${current_input_str:0:idx}" # substring
                    # do not change indentation in paragraph mode
                    if [[ $at_least_one_occurrence_on_line -eq 0 && $paragraph_size_p -eq 0 ]]; then
                        tmp_str="${tmp_str#"${tmp_str%%[![:space:]]*}"}" # left trim
                    fi
                    tmp_abbreviated_str=$(abbreviate "$tmp_str")
                    echo -n "$tmp_abbreviated_str"
                fi
                next_idx=$((idx + $searched_str_length))
                length=$((next_idx - idx))
                tmp_str="${current_input_str:idx:length}" # substring
                echo -e -n "$highlight_color"
                echo -n "$tmp_str"
                echo -e -n "$NC"
                at_least_one_occurrence_on_line=1
                if [[ $next_idx -lt $current_input_str_length ]]; then
                    length=$((current_input_str_length - next_idx))
                    current_input_str="${current_input_str:next_idx:length}" # substring
                    current_input_str_length=${#current_input_str}
                else
                    break
                fi
            done
            echo

        # Case some characters are non printable
        else
            if [[ "$last_binary_filepath" != "$filepath" && $filepath_extracted -eq 1 ]]; then
                binary_line_msg="${highlight_color}binary line(s)${NC}"
                if [[ $skip_occurrence_number_display -eq 0 ]]; then
                    total_nb_lines_displayed=$((total_nb_lines_displayed + 1))
                    # searched_str_p deemed always present at this stage (explicit presence check can be disturbed by special characters)
                    echo -e "$FILEPATH_COLOR$total_nb_lines_displayed $reformatted_filepath_and_line_number_str$NC $binary_line_msg"
                 else
                    echo -e "$(display_spaces ${#total_nb_lines_displayed}) $FILEPATH_COLOR$reformatted_filepath_and_line_number_str$NC $binary_line_msg"
                 fi
                last_binary_filepath="$filepath"
            fi
        fi

    done

    if [[ $total_nb_lines_displayed -eq 0 ]]; then
        echo "no occurrence"
    fi
}

###################################################################################################

############
# Unit tests
############

check_test_condition() {
    local res=$1
    local exp=$2
    local testid=$3

    if [[ ${#res} != ${#exp} || "$res" != "$exp" ]]; then
        printf 'ERROR %d: \"%q\" is different from \"%q\" (%d, %d)\n' "$testid" "$res" "$exp" "${#res}" "${#exp}" >&2
    else
        echo "OK $testid"
    fi
}

unit_tests() {
    echo "Running unit tests..."

    MAX_ABBREVIATION_LEN=10000
    MAX_LEN_FOR_LINE_SPLIT=10000

    complex_str="       019AbcD  E  FxYZ,,?&|+;;.  ...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( )) ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA               "
    trimmed_complex_str="${complex_str#"${complex_str%%[![:space:]]*}"}"  # left trim
    trimmed_complex_str="${trimmed_complex_str%"${trimmed_complex_str##*[![:space:]]}"}"  # right trim

    test_idx=1

    # (string not found)
    res=$(echo "./a/b/c/file name.cpp:123:  aBc  " | format_output "aBcX" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}$no_match${NC} aBc")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:$complex_str" | format_output "" "" "" 0 2>&1);
    if [[ "$res" == *"empty searched_str_p"* ]]; then
        echo "OK $((test_idx++))"
    else
        echo "ERROR $((test_idx++))"
    fi

    res=$(echo "./a/b/c/file name.cpp:123:" | format_output "ABC" "" "" 0 2>&1);
    if [[ "$res" == *"unexpected empty matching line for"* ]]; then
        echo "OK $((test_idx++))"
    else
        echo "ERROR $((test_idx++))"
    fi

    # (basic [with spaces])
    res=$(echo "./a/b/c/file name.cpp:123:aBc" | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}aBc${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.hpp:123: aBc " | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.hpp:123${NC}\t${HEADER_COLOR}aBc${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.txt:123:  aBc  " | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.txt:123${NC}\t${OTHER_COLOR}aBc${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name:123:   aBc   " | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name:123${NC}\t${OTHER_COLOR}aBc${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:1:   aBc   " | format_output " aBc  " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:1${NC}\t${SOURCE_COLOR} aBc  ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:1234567890:   aBc   " | format_output "   aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:1234567890${NC}\t${SOURCE_COLOR}   aBc${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:   aBc   " | format_output "aBc   " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}aBc   ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:   aBc   " | format_output "    aBc" "" "" 0 2>&1);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}$no_match${NC} aBc")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:   aBc   " | format_output "aBc    " "" "" 0 2>&1);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}$no_match${NC} aBc")
    check_test_condition "$res" "$exp" $((test_idx++))

    test_idx=100
    # (special characters)
    res=$(echo "./a/b/c/file name.cpp:123:aBc -a -i --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc -a -i ${SOURCE_COLOR}--${NC}  ${SOURCE_COLOR}--${NC}${SOURCE_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc + ++  +++++ edF" | format_output "++" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc + ${SOURCE_COLOR}++${NC}  ${SOURCE_COLOR}++${NC}${SOURCE_COLOR}++${NC}+ edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc * **  ***** edF" | format_output "**" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc * ${SOURCE_COLOR}**${NC}  ${SOURCE_COLOR}**${NC}${SOURCE_COLOR}**${NC}* edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc ^ ^^  ^^^^^ edF" | format_output "^^" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc ^ ${SOURCE_COLOR}^^${NC}  ${SOURCE_COLOR}^^${NC}${SOURCE_COLOR}^^${NC}^ edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc \$ \$\$  \$\$\$\$\$ edF" | format_output "\$\$" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc \$ ${SOURCE_COLOR}\$\$${NC}  ${SOURCE_COLOR}\$\$${NC}${SOURCE_COLOR}\$\$${NC}\$ edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc ( ()  ( (()()) edF" | format_output "()" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc ( ${SOURCE_COLOR}()${NC}  ( (${SOURCE_COLOR}()${NC}${SOURCE_COLOR}()${NC}) edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc ( []  [ [[][]] edF" | format_output "[]" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc ( ${SOURCE_COLOR}[]${NC}  [ [${SOURCE_COLOR}[]${NC}${SOURCE_COLOR}[]${NC}] edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc ( {}  { {{}{}} edF" | format_output "{}" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc ( ${SOURCE_COLOR}{}${NC}  { {${SOURCE_COLOR}{}${NC}${SOURCE_COLOR}{}${NC}} edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc  /  /  edF" | format_output "/" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc  ${SOURCE_COLOR}/${NC}  ${SOURCE_COLOR}/${NC}  edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc  \"  \"  edF" | format_output "\"" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc  ${SOURCE_COLOR}\"${NC}  ${SOURCE_COLOR}\"${NC}  edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc  '  '  edF" | format_output "'" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc  ${SOURCE_COLOR}'${NC}  ${SOURCE_COLOR}'${NC}  edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:aBc  \`  \`  edF" | format_output "\`" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc  ${SOURCE_COLOR}\`${NC}  ${SOURCE_COLOR}\`${NC}  edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:### #" | format_output "#" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}#${NC}${SOURCE_COLOR}#${NC}${SOURCE_COLOR}#${NC} ${SOURCE_COLOR}#${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:xxxxxxx" | format_output "xxx" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}xxx${NC}${SOURCE_COLOR}xxx${NC}x")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:          " | format_output "        " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}        ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (substring at the beginning of string)
    res=$(echo "./a/b/c/file name.cpp:123://x//xx//xxx// edF" | format_output "//" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}//${NC}x${SOURCE_COLOR}//${NC}xx${SOURCE_COLOR}//${NC}xxx${SOURCE_COLOR}//${NC} edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (substring at the end of string)
    res=$(echo "./a/b/c/file name.cpp:123://x//xx//xxx//" | format_output "//" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}//${NC}x${SOURCE_COLOR}//${NC}xx${SOURCE_COLOR}//${NC}xxx${SOURCE_COLOR}//${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (spaces only)
    res=$(echo "./a/b/c/file name.cpp:123:   aBc    deF   " | format_output "   " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}   ${NC}aBc${SOURCE_COLOR}   ${NC} deF${SOURCE_COLOR}   ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:     aBc     deF     " | format_output "   " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}   ${NC}  aBc${SOURCE_COLOR}   ${NC}  deF${SOURCE_COLOR}   ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (ignore case)
    res=$(echo "./a/b/c/file name.cpp:123: abcDEF  " | format_output "ABCdef " "" "" 0 2>&1);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}$no_match${NC} abcDEF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:  abcDEF " | format_output "ABCdef " "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}abcDEF ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    test_idx=200
    # (complex_str)
    # (first half of complex_str)
    res=$(echo "./a/b/c/file name.xxx:123:$complex_str" | format_output "AbcD  E  FxYZ,,?&|+;;.  ...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( ))" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC}\t019${OTHER_COLOR}AbcD  E  FxYZ,,?&|+;;.  ...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( ))${NC} ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (second half of complex_str)
    res=$(echo "./a/b/c/file name.xxx:123:$complex_str" | format_output " ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC}\t019AbcD  E  FxYZ,,?&|+;;.  ...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( ))${OTHER_COLOR} ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:$complex_str" | format_output "  E  FxYZ,,?&|+;;.  " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t019AbcD${SOURCE_COLOR}  E  FxYZ,,?&|+;;.  ${NC}...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( )) ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.hpp:123:$complex_str" | format_output "  e  FXYZ,,?&|+;;.  " "" "" 0 2>&1);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.hpp:123${NC}\t${HEADER_COLOR}$no_match${NC} $trimmed_complex_str")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:$complex_str" | format_output "  e  FXYZ,,?&|+;;.  " "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t019AbcD${SOURCE_COLOR}  E  FxYZ,,?&|+;;.  ${NC}...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( )) ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:$complex_str" | format_output "² <>aA" "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t019AbcD  E  FxYZ,,?&|+;;.  ...:://!! != §%% * **    ****    µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( )) ( ) () [[ ]] [ ] [] ° @ / // /* */ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ${SOURCE_COLOR}² <>aA${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:$complex_str" | format_output "* " "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t019AbcD  E  FxYZ,,?&|+;;.  ...:://!! != §%% ${SOURCE_COLOR}* ${NC}*${SOURCE_COLOR}* ${NC}   ***${SOURCE_COLOR}* ${NC}   µùéèàâêîôûŷäëïöüÿãẽĩõũỹ^^¨¨\$\$££ = == === {{}} {} + ++ +++ (( )) ( ) () [[ ]] [ ] [] ° @ / // /${SOURCE_COLOR}* ${NC}*/ ^ ^^ _ __ \ \\ \` -  -- ---  | || ' '' ''' \" \"\" ## # \" ~ & && ² <>aA")
    check_test_condition "$res" "$exp" $((test_idx++))

    test_idx=300
    # (correlated strings)
    res=$(correlated_strings "abc" "dabe" 0 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "dae" "ab" 1 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "abc" "abc" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "aBc" "AbC" 0 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "aBc" "AbC" 1 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "xxxdabc" "d" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "xxxdabc" "Da" 0 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "xxxdabc" "Dab" 1 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "d" "xxxdabc" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "Da" "xxxdabc" 0 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "Dab" "xxxdabc" 1 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "xxxda" "abc_" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "xxxdabc" "abc_" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "xxxdabc" "aBc_" 0 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "xxxdabc" "aBc_" 1 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings  "abc_" "xxxda" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "abc_" "xxxdabc" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "aBc_""xxxdabc" 0 0)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "aBc_" "xxxdabc" 1 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "\\" "\\" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "\$\\" "\\^" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "\\^" "\$\\" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "%µ" "µ¨¨¨¨" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "µ¨¨¨¨" "%µ" 0 0)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "abc" "abc" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "abc" "a" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "a" "abc" 0 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "xdabc" "abc_" 0 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "abc_" "xabc" 0 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "a,b,cd" "!efg" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "!efg" "a,b,cd" 0 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "a,b,cd" "b!cd" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "b!cd" "a,b,cd" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "b!cdxxx" "yyya,b,cd" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "a,b,cdxxx" "!a!b!" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "!a!b!" ",,a,b!xxx" 0 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "A,b;cd" "\$\\a!B-" 1 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "\$\\a!B-" "A,b;cd" 1 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "\$\\a!B-" "A,b;;cd" 1 1)
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(correlated_strings "a" "" 1 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    res=$(correlated_strings "" "a" 1 1)
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))

    test_idx=400
    # (non-printable characters)
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< " Hel  lo ")" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'\x00')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'a\x00b')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'\x01')" != "" ]]; then # code duplicated from actual code"
        res=1
    else
        res=0
    fi
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'\ax02b')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'    abc   \x08\x08   def   ')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="1"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'\x0D')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'\x09')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'a\x09b')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< $'abc\x09\x0Ddef')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))
    if [[ "$(sed 's/[[:print:][:blank:]\x0D\x09]//g' <<< 'abcµùéèàâêîôûŷäëïöüÿãẽĩõũỹdef')" != "" ]]; then # code duplicated from actual code
        res=1
    else
        res=0
    fi
    exp="0"
    check_test_condition "$res" "$exp" $((test_idx++))

    # (binary lines)
    res=$(echo $'./a/b/c/file name.cpp:123:xx\x01aBcxx' | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\txx\x01${SOURCE_COLOR}aBc${NC}xx")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo $'./a/b/c/file name.xxx:123:xx\x01aBcxx' | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC} ${OTHER_COLOR}binary line(s)${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo $'./a/b/c/file name.bin:123:xxaBcxx' | format_output "aBc" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.bin:123${NC} ${OTHER_COLOR}binary line(s)${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo $'./a/b/c/file name.cpp:123: aBcAbcd \x00DEF ' | format_output "Abcd" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc${SOURCE_COLOR}Abcd${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (non-ASCII character: µ is encoded on 2 bytes)
    res=$(echo "./a/b/c/file name.cpp:123:µµµabcDEF" | format_output "µµabcD" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tµ${SOURCE_COLOR}µµabcD${NC}EF")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (non-ASCII character: § is encoded on 2 bytes)
    res=$(echo "./a/b/c/file name.cpp:123:x§µ§abcD§EF" | format_output "§abcD§" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tx§µ${SOURCE_COLOR}§abcD§${NC}EF")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x09=\t shall be ignored for binary line detection)
    res=$(echo $'./a/b/c/file name.hpp:123:AB\x09abcDE\tF' | format_output $'\x09' "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.hpp:123${NC}\t")
    exp=$(echo -e "${exp}AB${HEADER_COLOR}\t${NC}abcDE${HEADER_COLOR}\t${NC}F")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x09=\t shall be ignored for binary line detection)
    res=$(echo $'./a/b/c/file name.hpp:123:AB\x09abcDEF' | format_output $'b\x09a' "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.hpp:123${NC}\t")
    exp=$(echo -e "${exp}A${HEADER_COLOR}B\ta${NC}bcDEF")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x0D=\r shall be ignored for binary line detection when at line end)
    res=$(echo $'./a/b/c/file name.xxx:123:AB\x0DabcDE\rFGH' | format_output $'\x0D' "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC} ${OTHER_COLOR}binary line(s)${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x0D=\r shall be ignored for binary line detection when at line end)
    res=$(echo $'./a/b/c/file name.xxx:123:AB\rabcDE\r' | format_output $'\x0D' "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC} ${OTHER_COLOR}binary line(s)${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x0D=\r shall be ignored for binary line detection when at line end)
    res=$(echo $'./a/b/c/file name.xxx:123:AB\rabcDE\x0D' | format_output "AB" "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC} ${OTHER_COLOR}binary line(s)${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x0D=\r shall be ignored for binary line detection when at line end)
    res=$(echo $'./a/b/c/file name.xxx:123:ABabcDE\r' | format_output $'\x0D' "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC}\t")
    exp=$(echo -e "${exp}ABabcDE${OTHER_COLOR}\r${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (\x0D=\r shall be ignored for binary line detection when at line end)
    res=$(echo $'./a/b/c/file name.xxx:123:ABabcDE\r' | format_output "AB" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.xxx:123${NC}\t")
    exp=$(echo -e "${exp}${OTHER_COLOR}AB${NC}abcDE")
    check_test_condition "$res" "$exp" $((test_idx++))

    test_idx=500
    # (file path and line number extraction)
    res=$(echo "./a/b/c/file name.cpp:123:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\taBc - ${SOURCE_COLOR}--${NC}  ${SOURCE_COLOR}--${NC}${SOURCE_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.hpp:123: aBc - --  ----- edF " | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.hpp:123${NC}\taBc - ${HEADER_COLOR}--${NC}  ${HEADER_COLOR}--${NC}${HEADER_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./x:1:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 x:1${NC}\taBc - ${OTHER_COLOR}--${NC}  ${OTHER_COLOR}--${NC}${OTHER_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:456:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t456:aBc - ${SOURCE_COLOR}--${NC}  ${SOURCE_COLOR}--${NC}${SOURCE_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:xyz:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\txyz:aBc - ${SOURCE_COLOR}--${NC}  ${SOURCE_COLOR}--${NC}${SOURCE_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:xyz:123:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:xyz:123${NC}\taBc - ${OTHER_COLOR}--${NC}  ${OTHER_COLOR}--${NC}${OTHER_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./x:y:1:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 x:y:1${NC}\taBc - ${OTHER_COLOR}--${NC}  ${OTHER_COLOR}--${NC}${OTHER_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:xxx:123" | format_output "B" "" "" 0 2>&1);
    if [[ "$res" == *"cannot extract filepath and line number from"* ]]; then
        echo "OK $((test_idx++))"
    else
        echo "ERROR $((test_idx++))"
    fi

    res=$(echo "./a/b/c/file name.cpp:xyz:123:" | format_output "ABC" "" "" 0 2>&1);
    if [[ "$res" == *"unexpected empty matching line for"* ]]; then
        echo "OK $((test_idx++))"
    else
        echo "ERROR $((test_idx++))"
    fi

    test_idx=600
    # (word case)
    res=$(echo "./a/b/c/file name.cpp:123:ABc xABC _ABC abc ABCy ABC_ zaBCt ,ABC, (ABC) ;ABC; ABC" | format_output "Abc" "$grep_ignorecase_option" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}ABc${NC} xABC _ABC ${SOURCE_COLOR}abc${NC} ABCy ABC_ zaBCt ,${SOURCE_COLOR}ABC${NC}, (${SOURCE_COLOR}ABC${NC}) ;${SOURCE_COLOR}ABC${NC}; ${SOURCE_COLOR}ABC${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123: ABc d xABC d _ABC d abc d ABC dy ABC d_ zaBC dt ,ABC d, (ABC d) ;ABC d; ABC d " | format_output "Abc d" "$grep_ignorecase_option" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}ABc d${NC} xABC d _ABC d ${SOURCE_COLOR}abc d${NC} ABC dy ABC d_ zaBC dt ,${SOURCE_COLOR}ABC d${NC}, (${SOURCE_COLOR}ABC d${NC}) ;${SOURCE_COLOR}ABC d${NC}; ${SOURCE_COLOR}ABC d${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:_Abc d  Abc d_x" | format_output "Abc d" "" "$grep_word_option" 0 2>&1);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR}$no_match${NC} _Abc d  Abc d_x")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123: ABc d  ABc d   ABc d " | format_output " Abc d " "$grep_ignorecase_option" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR} ABc d ${NC}${SOURCE_COLOR} ABc d ${NC} ${SOURCE_COLOR} ABc d ${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123: ABc d  ABc d x" | format_output " Abc d " "$grep_ignorecase_option" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t${SOURCE_COLOR} ABc d ${NC} ABc d x")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123: xxx,Abc d,_Abc de+Abc d-;Abc d" | format_output "Abc d" "" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\txxx,${SOURCE_COLOR}Abc d${NC},_Abc de+${SOURCE_COLOR}Abc d${NC}-;${SOURCE_COLOR}Abc d${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:Aaa Aaa A" | format_output "Aaa A" "" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tAaa ${SOURCE_COLOR}Aaa A${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123: Aaa Aaa A Aaa A " | format_output "Aaa A" "" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tAaa ${SOURCE_COLOR}Aaa A${NC} ${SOURCE_COLOR}Aaa A${NC}")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (abbreviation)
    MAX_ABBREVIATION_LEN=5
    res=$(echo "./a/b/c/file name.cpp:123:01234567890123456789abcdefghij01234567890123456789abcdefghij01234567890123456789" | format_output "abcdefghij" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t01234567890123456789${SOURCE_COLOR}abcdefghij${NC}01234567890123456789${SOURCE_COLOR}abcdefghij${NC}01234567890123456789")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:01234567890123456789XabcdefghijY01234567890123456789abcdefghijZ01234567890123456789" | format_output "abcdefghij" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t01234${abbreviation_str}6789X${SOURCE_COLOR}abcdefghij${NC}Y0123${abbreviation_str}56789${SOURCE_COLOR}abcdefghij${NC}Z0123${abbreviation_str}56789")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123: 01234567890123456789X aBcdefghij Y01234567890123456789 aBcdefghij Z01234567zzzzzzzzzzzzzzzzzzzzzzzzzzzz890123456789 " | format_output "AbcdefghiJ" "$grep_ignorecase_option" "$grep_word_option" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t01234${abbreviation_str}789X ${SOURCE_COLOR}aBcdefghij${NC} Y012${abbreviation_str}6789 ${SOURCE_COLOR}aBcdefghij${NC} Z012${abbreviation_str}56789")
    check_test_condition "$res" "$exp" $((test_idx++))
    MAX_ABBREVIATION_LEN=10000

    # (line split)
    MAX_LEN_FOR_LINE_SPLIT=55
    res=$(echo "./a/b/c/file name.cpp:123:                                     ABCDEFGHIJKLMNOPQRSTUVWXYZ                               " | format_output "DEF" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZ")
    check_test_condition "$res" "$exp" $((test_idx++))

    MAX_LEN_FOR_LINE_SPLIT=45
    res=$(echo "./a/b/c/file name.cpp:123:                                     ABCDEFGHIJKLMNOPQRSTUVWXYZ                               " | format_output "DEF" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\nABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZ")
    check_test_condition "$res" "$exp" $((test_idx++))
    MAX_LEN_FOR_LINE_SPLIT=10000

    test_idx=700
    # (paragraphs)
    res=$(echo "./a/b/c/file name.cpp:123:  xxxxxxx  " | format_output "xxx" "" "" 1);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\t  ${SOURCE_COLOR}xxx${NC}${SOURCE_COLOR}xxx${NC}x")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp-123-xxxxxxx" | format_output "xxx" "" "" 2);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\t${SOURCE_COLOR}xxx${NC}${SOURCE_COLOR}xxx${NC}x\nno occurrence")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name *+ ~|()!?:12  12a-1abc-456a-.hpp-123-  aBc --  78 " | format_output "--" "" "" 2);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name *+ ~|()!?:12  12a-1abc-456a-.hpp-123${NC}\t  aBc ${HEADER_COLOR}--${NC}  78\nno occurrence")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (file path and line number extraction in paragraph mode)
    res=$(echo "./a/b/c/file name.cpp-123-456-xxxxxxx" | format_output "xxx" "" "" 2);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\t456-${SOURCE_COLOR}xxx${NC}${SOURCE_COLOR}xxx${NC}x\nno occurrence")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp-abc-456-xxxxxxx" | format_output "xxx" "" "" 2);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-abc-456${NC}\t${OTHER_COLOR}xxx${NC}${OTHER_COLOR}xxx${NC}x\nno occurrence")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp-123-xxx:456:aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp-123-xxx:456${NC}\taBc - ${OTHER_COLOR}--${NC}  ${OTHER_COLOR}--${NC}${OTHER_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp-123-xxx:456:aBc - --  ----- edF" | format_output "--" "" "" 2);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\txxx:456:aBc - ${SOURCE_COLOR}--${NC}  ${SOURCE_COLOR}--${NC}${SOURCE_COLOR}--${NC}- edF\nno occurrence")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo "./a/b/c/file name.cpp:123:xxx-456-aBc - --  ----- edF" | format_output "--" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\txxx-456-aBc - ${SOURCE_COLOR}--${NC}  ${SOURCE_COLOR}--${NC}${SOURCE_COLOR}--${NC}- edF")
    check_test_condition "$res" "$exp" $((test_idx++))

    # (extraction error in paragraph mode)
    res=$(echo "./a/b/c/file name.cpp:abc:def-" | format_output "B" "" "" 2 2>&1);
    if [[ "$res" == *"cannot extract filepath and line number from"* ]]; then
        echo "OK $((test_idx++))"
    else
        echo "ERROR $((test_idx++))"
    fi
    # (extraction error in paragraph mode)
    res=$(echo "./a/b/c/file name.cpp:abc:def--" | format_output "B" "" "" 2 2>&1);
    if [[ "$res" == *"cannot extract filepath and line number from"* ]]; then
        echo "OK $((test_idx++))"
    else
        echo "ERROR $((test_idx++))"
    fi

    test_idx=800
    # (multi-line)
    res=$(echo -e "./a/b/c/file name.cpp:123: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n./a/b/c/file name.cpp:123: aaABCDEFGHIJKLMNOPQRSTUVWXYZzz" | format_output "DEF" "" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZ\n${FILEPATH_COLOR}2 a/b/c/file name.cpp:123${NC}\taaABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZzz")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo -e "./a/b/c/file name.cpp:123: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n./a/b/c/file name.cpp:123: aaABCDEFGHIJKLMNOPQRSTUVWXYZzz\n./a/b/c/file name.cpp:123:   aaaABCDEFGHIJKLMNOPQRSTUVWXYZzzz   " | format_output "def" "$grep_ignorecase_option" "" 0);
    exp=$(echo -e "${FILEPATH_COLOR}1 a/b/c/file name.cpp:123${NC}\tABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZ\n${FILEPATH_COLOR}2 a/b/c/file name.cpp:123${NC}\taaABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZzz\n${FILEPATH_COLOR}3 a/b/c/file name.cpp:123${NC}\taaaABC${SOURCE_COLOR}DEF${NC}GHIJKLMNOPQRSTUVWXYZzzz")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo -e "./a/b/c/file name.cpp-123- xAbCDEF GHIJKLMNOPQRSTUVWXYZ\n./a/b/c/file name.cpp:124: a,ABCDEF,GHIJKLMNOPQRSTUVWXYZzz\n./a/b/c/file name.cpp-125-   aaaabcdefGHIJKLMNOPQRSTUVWXYZzzz   " | format_output "aBcDeF" "$grep_ignorecase_option" "" 1);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\t x${SOURCE_COLOR}AbCDEF${NC} GHIJKLMNOPQRSTUVWXYZ\n${FILEPATH_COLOR}1 a/b/c/file name.cpp:124${NC}\t a,${SOURCE_COLOR}ABCDEF${NC},GHIJKLMNOPQRSTUVWXYZzz\n  ${FILEPATH_COLOR}a/b/c/file name.cpp-125${NC}\t   aaa${SOURCE_COLOR}abcdef${NC}GHIJKLMNOPQRSTUVWXYZzzz\n")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo -e "./a/b/c/file name.cpp-123-\n./a/b/c/file name.cpp:124: a,ABCDEF,GHIJKLMNOPQRSTUVWXYZzz\n./a/b/c/file name.cpp-125-   aaaabcdefGHIJKLMNOPQRSTUVWXYZzzz   " | format_output "aBcDeF" "$grep_ignorecase_option" "" 1);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\n${FILEPATH_COLOR}1 a/b/c/file name.cpp:124${NC}\t a,${SOURCE_COLOR}ABCDEF${NC},GHIJKLMNOPQRSTUVWXYZzz\n  ${FILEPATH_COLOR}a/b/c/file name.cpp-125${NC}\t   aaa${SOURCE_COLOR}abcdef${NC}GHIJKLMNOPQRSTUVWXYZzzz\n")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo -e "./a/b/c/file name.cpp-123- xAbCDEF GHIJKLMNOPQRSTUVWXYZ\n./a/b/c/file name.cpp:124: a,ABCDEF,GHIJKLMNOPQRSTUVWXYZzz\n./a/b/c/file name.cpp-125-   aaaabcdefGHIJKLMNOPQRSTUVWXYZzzz   " | format_output "aBcDeF" "$grep_ignorecase_option" "$grep_word_option" 1);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\t xAbCDEF GHIJKLMNOPQRSTUVWXYZ\n${FILEPATH_COLOR}1 a/b/c/file name.cpp:124${NC}\t a,${SOURCE_COLOR}ABCDEF${NC},GHIJKLMNOPQRSTUVWXYZzz\n  ${FILEPATH_COLOR}a/b/c/file name.cpp-125${NC}\t   aaaabcdefGHIJKLMNOPQRSTUVWXYZzzz\n")
    check_test_condition "$res" "$exp" $((test_idx++))

    res=$(echo -e "./a/b/c/file name.cpp-123- xAbCDEF GHIJKLMNOPQRSTUVWXYZ\n./a/b/c/file name.cpp:124: a,ABCDEF,GHIJKLMNOPQRSTUVWXYZzz\n./a/b/c/file name.cpp:125: aa,ABCDEF,GHIJKLMNOPQRSTUVWXYZzzz\n./a/b/c/file name.cpp-126-   aaaabcdefGHIJKLMNOPQRSTUVWXYZzzz   " | format_output "aBcDeF" "$grep_ignorecase_option" "$grep_word_option" 1);
    exp=$(echo -e "  ${FILEPATH_COLOR}a/b/c/file name.cpp-123${NC}\t xAbCDEF GHIJKLMNOPQRSTUVWXYZ\n${FILEPATH_COLOR}1 a/b/c/file name.cpp:124${NC}\t a,${SOURCE_COLOR}ABCDEF${NC},GHIJKLMNOPQRSTUVWXYZzz\n${FILEPATH_COLOR}2 a/b/c/file name.cpp:125${NC}\t aa,${SOURCE_COLOR}ABCDEF${NC},GHIJKLMNOPQRSTUVWXYZzzz\n  ${FILEPATH_COLOR}a/b/c/file name.cpp-126${NC}\t   aaaabcdefGHIJKLMNOPQRSTUVWXYZzzz\n")
    check_test_condition "$res" "$exp" $((test_idx++))

    multiline_str=$(echo -e "AAA\nBBB\nCCC\n$paragraph_separator\nDDD\nEEE\n\n$paragraph_separator\nFFF\nGGG\nHHH")
    separate_paragraph_lines_command_args="s/${paragraph_line_separator}/\n/g" # code duplicated from actual code
    separate_paragraph_lines_command="| sed \"$separate_paragraph_lines_command_args\" " # code duplicated from actual code
    gather_and_separate_command="gather_paragraph_lines $separate_paragraph_lines_command"
    res=$(echo "$multiline_str" | eval "$gather_and_separate_command")
    check_test_condition "$res" "$multiline_str" $((test_idx++))

    multiline_str=$(echo -e "AAA\n$complex_str\nCCC\n$paragraph_separator\n$complex_str\nEEE\n\n$paragraph_separator\nFFF\nGGG\n$complex_str")
    separate_paragraph_lines_command_args="s/${paragraph_line_separator}/\n/g" # code duplicated from actual code
    separate_paragraph_lines_command="| sed \"$separate_paragraph_lines_command_args\" " # code duplicated from actual code
    gather_and_separate_command="gather_paragraph_lines $separate_paragraph_lines_command"
    res=$(echo "$multiline_str" | eval "$gather_and_separate_command")
    check_test_condition "$res" "$multiline_str" $((test_idx++))

    # manual unit tests:
    echo "EXTRA TESTS TO BE DONE:"
    echo "manual unit tests shall also be run, see below instructions commented in the script"
    # manual tests shall cover all +/++/-/-- operations with all options -i/-p=N/-w
    # so that they work on a file containing the complex sequence of special characters
    # (once or several times on the same line / in the same paragraph when using option -p=N):
    # aa zz AA ZZ 00 99 __ ++ == // (( [[ {{ ... ~~ ^^ $$ ` ?? || :: ,, ;; ** )) ]] }}   \\ \ a\b\t\n  "" --''x' §°µùéèàâêîôûŷäëïöüÿãẽĩõũỹ%£@&¨#~²
    # => the following commands shall work:
    # fl "aa zz AA ZZ 00 99 __ ++ == // (( [[ {{ ... ~~ ^^ \$\$ \` ?? || :: ,, ;; ** )) ]] }}   \\\\ \\ a\\b\\t\\n  \"\" --''x' §°µùéèàâêîôûŷäëïöüÿãẽĩõũỹ%£@&¨#~²"
    # fl [options] "this test string" +/++/-/-- "this test string"
    # Note: ! character can also be searched if history expansion feature is temporarily disabled (with set +H)
}

###################################################################################################

###################
# Handle parameters
###################

nb_options=0
ignorecase=0
word=0
paragraphsize=0
first_str_parameter_idx=-1

options_list=""
pathstrs_list=""
pathstrs_list_for_call=""
strs_list=""
first_str_to_find=""
last_str_to_find=""
main_search_command=""
extra_search_command=""

parameter_idx=-1
for arg in "$@"; do
    ((parameter_idx++))

    # Options
    #########

    is_option=0
    if [[ "$nb_options" == "$parameter_idx" ]]; then
        if [[ $arg == -i ]]; then
            if [[ $ignorecase -eq 0 ]]; then
                ignorecase=1
                options_list="${options_list}IGNORECASE "
                ((nb_options++))
                is_option=1
            fi
        elif [[ $arg == -w ]]; then
            if [[ $word -eq 0 ]]; then
                word=1
                options_list="${options_list}WORD "
                ((nb_options++))
                is_option=1
            fi
        elif [[ $arg == -p=* ]]; then
            if [[ $paragraphsize -eq 0 ]]; then
                paragraphsize="${arg#*=}"
                if ! [[ "$paragraphsize" =~ ^[0-9]+$ ]]; then
                    printError "error: invalid option $arg: $paragraphsize is not a number"
                    exit 1
                fi
                if [[ "$paragraphsize" -lt 1 ]]; then
                    printError "error: invalid option $arg: $paragraphsize shall be >= 1"
                    exit 1
                fi
                options_list="${options_list}PARAGRAPH=$paragraphsize "
                ((nb_options++))
                is_option=1
            fi
        elif [[ $arg == -unit-tests ]]; then
            unit_tests
            exit 0
        fi
        if [[ $is_option -eq 1 ]]; then
            if [[ $((parameter_idx + 1)) == $# ]]; then
                printError "error: option $arg shall not be last parameter"
                exit 1
            fi
        fi
    fi

    # Parameters after options
    ##########################

    if [[ $is_option -eq 0 ]]; then
        if [[ "$arg" == "+" || "$arg" == "++" || "$arg" == "-" || "$arg" == "--" ]]; then
            if [[ $parameter_idx -le $nb_options ]]; then
                if [[ $nb_options -eq 0 ]]; then
                    printError "error: operator \"$arg\" shall not be first parameter"
                else
                    printError "error: operator \"$arg\" shall not be first parameter after options"
                fi
                exit 1
            fi
            if [[ $((parameter_idx + 1)) == $# ]]; then
                printError "error: operator \"$arg\" shall not be last parameter"
                exit 1
            fi
            if [[ $first_str_parameter_idx -eq -1 ]]; then
                first_str_parameter_idx=$((parameter_idx - 1))
            fi
        elif [[ $((parameter_idx + 1)) == $# ]]; then
            if [[ $first_str_parameter_idx -eq -1 ]]; then
                first_str_parameter_idx=$parameter_idx
            fi
        fi
    fi
done

if [[ $first_str_parameter_idx -eq -1 ]]; then
    printError "error: missing parameter(s): no string(s) to find"
    exit 1
fi

if [[ $ignorecase -eq 1 ]]; then
    grep_ignorecase_option_applied="$grep_ignorecase_option "
else
    grep_ignorecase_option_applied=""
fi
if [[ $word -eq 1 ]]; then
    grep_word_option_applied="$grep_word_option "
    # (^|$|[^a-zA-Z0-9_]) around word in regexp <=> grep -w option
    regexp_word_boundary="(^|$|[^a-zA-Z0-9_])"
else
    grep_word_option_applied=""
    regexp_word_boundary=""
fi
if [[ $paragraphsize -ge 1 ]]; then
    paragraph_option_applied="-C$paragraphsize --group-separator=\"$paragraph_separator\" "
    gather_paragraph_lines_command="| gather_paragraph_lines "
    separate_paragraph_lines_command_args="s/${paragraph_line_separator}/\n/g" # code duplicated in unit tests
    separate_paragraph_lines_command="| sed \"$separate_paragraph_lines_command_args\" " # code duplicated in unit tests
    skip_line_info=""
else
    paragraph_option_applied=""
    gather_paragraph_lines_command=""
    separate_paragraph_lines_command=""
    skip_line_info="^\./[^:]*:[0-9]+:.*"
fi

parameter_idx=-1
include_operator=1
first_extra_str=0
at_least_one_exclude_operator=0
for arg in "$@"; do
    ((parameter_idx++))
    if [[ $parameter_idx -ge $nb_options && $parameter_idx -le $((first_str_parameter_idx - 1)) ]]; then
        if [[ "$arg" =~ [[:blank:]] ]]; then
            pathstrs_list="$pathstrs_list\"$arg\" "
        else
            pathstrs_list="$pathstrs_list$arg "
        fi
        pathstrs_list_for_call="$pathstrs_list_for_call\"$arg\" "
    elif [[ $parameter_idx -ge $first_str_parameter_idx ]]; then
        if [[ "$arg" =~ [[:blank:]] ]]; then
            strs_list="$strs_list\"$arg\" "
        else
            strs_list="$strs_list$arg "
        fi
        if [[ "$arg" == "+" ]]; then
            include_operator=1
        elif [[ "$arg" == "++" ]]; then
            include_operator=2
        elif [[ "$arg" == "-" ]]; then
            include_operator=3
        elif [[ "$arg" == "--" ]]; then
            include_operator=4
        else
            if [[ $paragraphsize -ge 1 && ( "$arg" == "$character_separator"* || "$arg" == *"$character_separator" ) ]]; then
                printError "error: character \"$character_separator\" is used for separators in paragraph mode so shall not be at the start or end of parameters"
                exit 1
            fi
            reformatted_arg=$(escape_special_chars "$arg" | sed 's/\\/\\\\/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g' | sed 's/"/\\"/g')
            if [[ $parameter_idx -eq $first_str_parameter_idx ]]; then
                first_str_to_find="$arg"
                reformatted_first_str_to_find=$(escape_special_chars "$arg" | sed 's/\\/\\\\/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g' | sed 's/"/\\"/g')
                last_str_to_find="$arg"
                reformatted_last_str_to_find=$(escape_special_chars "$arg" | sed 's/\\/\\\\/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g' | sed 's/"/\\"/g')
                main_search_command="grep -E --text --with-filename -n $grep_ignorecase_option_applied$grep_word_option_applied$paragraph_option_applied-- \"$reformatted_arg\" "
            else
                if [[ "$last_str_to_find" == "" ]]; then
                    printError "error: empty last_str_to_find"
                    exit 1
                fi
                if [[ $include_operator -eq 1 ]]; then
                    correlated_strs=$(correlated_strings "$first_str_to_find" "$arg" $ignorecase $word)
                    # correlated_strs allows to check if "grep -E str1.*str2|str2.*str1" is equivalent to less efficient "grep str1 | grep str2"
                    if [[ $first_extra_str -eq 0 && "$paragraph_option_applied" == "" && $correlated_strs -eq 0 ]]; then
                        if [[ "$last_str_to_find" != "$first_str_to_find" ]]; then
                            printError "error: last_str_to_find != first_str_to_find #1"
                            exit 1
                        fi
                        # optimize main_search_command
                        main_search_command="grep -E --text --with-filename -n $grep_ignorecase_option_applied-- \"$regexp_word_boundary$reformatted_first_str_to_find$regexp_word_boundary.*$reformatted_arg|$reformatted_arg.*$regexp_word_boundary$reformatted_first_str_to_find$regexp_word_boundary\" "
                    else
                        # update extra_search_command
                        extra_search_command="$extra_search_command| grep -E --text $grep_ignorecase_option_applied-- \"$skip_line_info$reformatted_arg\" "
                    fi
                    last_str_to_find="$arg"
                    reformatted_last_str_to_find=$(escape_special_chars "$arg" | sed 's/\\/\\\\/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g' | sed 's/"/\\"/g')
                elif [[ $include_operator -eq 2 ]]; then
                    if [[ $first_extra_str -eq 0 && "$paragraph_option_applied" == "" ]]; then
                        if [[ "$last_str_to_find" != "$first_str_to_find" ]]; then
                            printError "error: last_str_to_find != first_str_to_find #2"
                            exit 1
                        fi
                        # optimize main_search_command
                        main_search_command="grep -E --text --with-filename -n $grep_ignorecase_option_applied-- \"$regexp_word_boundary$reformatted_first_str_to_find$regexp_word_boundary.*$reformatted_arg\" "
                    else
                        # update extra_search_command
                        if [[ $first_extra_str -eq 0 ]]; then
                            extra_search_command="$extra_search_command| grep -E --text $grep_ignorecase_option_applied-- \"$skip_line_info$regexp_word_boundary$reformatted_first_str_to_find$regexp_word_boundary.*$reformatted_arg\" "
                        else
                            extra_search_command="$extra_search_command| grep -E --text $grep_ignorecase_option_applied-- \"$skip_line_info$reformatted_last_str_to_find.*$reformatted_arg\" "
                        fi
                    fi
                    last_str_to_find="$arg"
                    reformatted_last_str_to_find=$(escape_special_chars "$arg" | sed 's/\\/\\\\/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g' | sed 's/"/\\"/g')
                elif [[ $include_operator -eq 3 ]]; then
                    extra_search_command="$extra_search_command| grep -E --text -v $grep_ignorecase_option_applied-- \"$skip_line_info$reformatted_arg\" "
                    at_least_one_exclude_operator=1
                elif [[ $include_operator -eq 4 ]]; then
                    if [[ $first_extra_str -eq 0 ]]; then
                        extra_search_command="$extra_search_command| grep -E --text -v $grep_ignorecase_option_applied-- \"$skip_line_info$regexp_word_boundary$reformatted_first_str_to_find$regexp_word_boundary.*$reformatted_arg\" "
                    else
                        extra_search_command="$extra_search_command| grep -E --text -v $grep_ignorecase_option_applied-- \"$skip_line_info$reformatted_last_str_to_find.*$reformatted_arg\" "
                    fi
                    at_least_one_exclude_operator=1
                else
                    printError "error: invalid include_operator: $include_operator"
                    exit 1
                fi
                first_extra_str=1
            fi
        fi
    fi
done

if [[ "$first_str_to_find" == "" ]]; then
    printError "error: first string to find is empty"
    exit 1
fi

############
# Processing
############

SCRIPT_DIR=$(dirname "$0")
reformatted_first_str_to_find=$(echo "$first_str_to_find" | sed 's/\\/\\\\/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g' | sed 's/"/\\"/g')
trimmed_grep_ignorecase_option_applied="${grep_ignorecase_option_applied%"${grep_ignorecase_option_applied##*[![:space:]]}"}" # right trim
trimmed_grep_word_option_applied="${grep_word_option_applied%"${grep_word_option_applied##*[![:space:]]}"}" # right trim
format_command="| format_output \"$reformatted_first_str_to_find\" \"$trimmed_grep_ignorecase_option_applied\" \"$trimmed_grep_word_option_applied\" \"$paragraphsize\" | expand -t 4"
if [[ $paragraphsize -ge 1 && "$extra_search_command" != "" ]]; then
    search_command="$SCRIPT_DIR/ff -print0 $pathstrs_list_for_call| xargs -0 $main_search_command$gather_paragraph_lines_command$extra_search_command$separate_paragraph_lines_command$format_command"
else
    search_command="$SCRIPT_DIR/ff -print0 $pathstrs_list_for_call| xargs -0 $main_search_command$extra_search_command$format_command"
fi

echo "**********************************************************************"
echo -n "find "
echo -n "$strs_list"
if [[ "$pathstrs_list" != "" ]]; then
    echo -n "in ${pathstrs_list}files "
else
    echo -n "in all files "
fi
if [[ "$options_list" != "" ]]; then
    echo "[ $options_list] "
else
    echo
fi

if [[ $paragraphsize -ge 1 && $at_least_one_exclude_operator -ne 0 ]]; then
    echo "${BOLD}warning:$NC in paragraph mode (-p=N option), some occurrences may be missing if some strings excluded with \"-\" or \"--\" are part of the filepaths or matching line numbers" >&2
fi

# echo "search_command=$search_command"
eval "$search_command"
